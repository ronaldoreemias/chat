<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat com AI</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .caixa{
        display: flex;
        flex-direction: column;
        width: 90%;
        height: 100%;
        padding: 10px;
        overflow-y: auto; /* Barra de rolagem apenas vertical */
        }
   
    </style>
</head>
<body>
    <header>
        <h2>Converse com nossa I.A</h2>
    </header>
    <main>
        <div class="caixa" id="chat-container">
            <div class="user-message" style="width: 100%; max-width: 300px; background-color: red; color: white; margin: 0;">
                <h3>ATENÇÃO ! caso for pesquisar</h3>
                <p>escreva "pesquise sobre" antes do que quer pesquisar</p>
            </div>

        </div>
    </main>
    <footer>
        <div>
            <input type="text" id="user-input" placeholder="Pergunte alguma coisa...">
            <button onclick="processInput()">Enviar</button>
        </div>
    </footer>
    <script>
        // Função para normalizar o texto removendo acentos e caracteres especiais
        function normalizeText(text) {
            return text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
        }
        
        // Função para dividir uma string em tokens
        function tokenize(text) {
            return normalizeText(text).split(' ').filter(token => token.trim() !== '');
        }
        
        // Função para calcular a similaridade de strings usando string-similarity
        function calculateSimilarity(str1, str2) {
            const normalize = text => text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
            return stringSimilarity.compareTwoStrings(normalize(str1), normalize(str2));
        }
        
        let awaitingUserResponse = false;
        let currentQuestion = '';
        
        // Carregar respostas salvas do localStorage
        let savedResponses = JSON.parse(localStorage.getItem('savedResponses')) || {};
        
        async function processInput() {
            const userInput = document.getElementById('user-input').value;
        
            if (userInput.trim() === '') {
                return;
            }
        
            displayMessage(userInput, 'user');
        
            if (awaitingUserResponse) {
                // Salvar a resposta do usuário
                saveNewResponse(currentQuestion, userInput);
                awaitingUserResponse = false;
                currentQuestion = '';
                displayMessage(`Obrigado! Sua resposta foi salva.`, 'ai');
                document.getElementById('user-input').value = '';
                return;
            }
        
            // Verificar se a pergunta começa com "pesquise sobre"
            if (userInput.toLowerCase().startsWith('pesquise sobre')) {
                const query = userInput.substring(14).trim(); // Subtrair o comprimento da string "pesquise sobre"
                await searchAndDisplayResults(query);
                document.getElementById('user-input').value = '';
                return;
            }
        
            // Verificar se a pergunta já tem uma resposta salva
            if (savedResponses[userInput]) {
                displayMessage(savedResponses[userInput], 'ai');
                document.getElementById('user-input').value = '';
                return;
            }
        
            // Carregar as respostas prontas do arquivo JSON
            const predefinedResponses = await fetch('respostas.json')
                .then(response => response.json())
                .catch(error => {
                    displayMessage(`Erro ao carregar respostas prontas: ${error.message}`, 'ai');
                    return {};
                });
        
            // Encontrar a resposta mais semelhante
            let bestMatch = '';
            let highestSimilarity = 0;
        
            for (const [question, answer] of Object.entries(predefinedResponses)) {
                const similarity = calculateSimilarity(userInput, question);
        
                if (similarity > highestSimilarity) {
                    highestSimilarity = similarity;
                    bestMatch = answer;
                }
            }
        
            // Definir um limite de similaridade (ajustar conforme necessário)
            const similarityThreshold = 0.5;
        
            if (highestSimilarity >= similarityThreshold) {
                displayMessage(bestMatch, 'ai');
            } else {
                // Se não encontrar uma resposta, perguntar ao usuário
                currentQuestion = userInput;
                awaitingUserResponse = true;
                displayMessage(`Eu não tenho uma resposta para isso agora. Você sabe a resposta para a pergunta: "${userInput}"?`, 'ai');
            }
        
            document.getElementById('user-input').value = '';
        }
        
        async function searchAndDisplayResults(query) {
            try {
                const searchResults = await fetch(`https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_redirect=1&t=h_&ia=web`, {
                    method: 'GET'
                });
        
                if (!searchResults.ok) {
                    throw new Error('Erro na solicitação de busca');
                }
        
                const data = await searchResults.json();
                const topResults = data.RelatedTopics.slice(0, 3);
        
                let responses = '';
        
                topResults.forEach((result, index) => {
                    if (result.FirstURL && result.Text) { 
                        responses += `
                            <div>
                                <strong>Opção ${index + 1}:</strong> <a href="${result.FirstURL}" target="_blank">${result.Text}</a>
                            </div>
                        `;
                    }
                });
        
                if (responses === '') {
                    responses = 'Desculpe, não conseguimos encontrar resultados relevantes desta vez. Vamos tentar de novo?';
                }
        
                displayMessage(responses, 'ai');
            } catch (error) {
                displayMessage(`Desculpe, houve um erro ao realizar a busca: ${error.message}`, 'ai');
            }
        }
        
        function displayMessage(message, sender) {
            const chatContainer = document.getElementById('chat-container');
            const messageBubble = document.createElement('div');
            messageBubble.className = sender === 'user' ? 'user-message' : 'ai-message';
            messageBubble.innerHTML = message;  // Use innerHTML to render HTML content
            chatContainer.appendChild(messageBubble);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        
        function saveNewResponse(question, answer) {
            savedResponses[question] = answer; // Salvar a resposta no objeto
            localStorage.setItem('savedResponses', JSON.stringify(savedResponses)); // Salvar no localStorage
            console.log('Nova resposta salva:', question, answer);
        }
        
        // Incluir a biblioteca string-similarity
        const stringSimilarity = {
            compareTwoStrings: function (first, second) {
                first = first.replace(/\s+/g, '');
                second = second.replace(/\s+/g, '');
        
                if (first === second) return 1; // identical or empty
                if (first.length < 2 || second.length < 2) return 0; // if either is a 0-letter or 1-letter string
        
                let firstBigrams = new Map();
                for (let i = 0; i < first.length - 1; i++) {
                    const bigram = first.substring(i, i + 2);
                    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) + 1 : 1;
                    firstBigrams.set(bigram, count);
                }
        
                let intersectionSize = 0;
                for (let i = 0; i < second.length - 1; i++) {
                    const bigram = second.substring(i, i + 2);
                    const count = firstBigrams.has(bigram) ? firstBigrams.get(bigram) - 1 : 0;
        
                    if (count > 0) {
                        firstBigrams.set(bigram, count);
                        intersectionSize++;
                    }
                }
        
                return (2.0 * intersectionSize) / (first.length + second.length - 2);
            }
        };
    </script>
        
        
        
</body>
</html>
